"""Test gates defined in `qibo/core/cgates.py` and `qibo/core/gates.py` for density matrices."""
import pytest
import numpy as np
import qibo
from qibo import gates
from qibo.config import raise_error


def random_density_matrix(nqubits):
    """Generates a random density matrix.

    Note that the density matrix generated by this method is not necessarily
    positive. This is okay for most tests but may not work for some cases such
    as the entanglement entropy calculation.

    Args:
        nqubits (int): Number of qubits in the density matrix.

    Returns:
        Density matrix as a numpy array of shape (2 ** nqubits, 2 ** nqubits).
    """
    shape = 2 * (2 ** nqubits,)
    rho = np.random.random(shape) + 1j * np.random.random(shape)
    # Make Hermitian
    rho = (rho + rho.T.conj()) / 2.0
    # Normalize
    ids = np.arange(2 ** nqubits)
    rho[ids, ids] = rho[ids, ids] / np.trace(rho)
    return rho


@pytest.mark.parametrize("qubit", [0, 1, 2])
def test_partial_trace_gate(backend, qubit):
    original_backend = qibo.get_backend()
    qibo.set_backend(backend)

    gate = gates.PartialTrace(qubit)
    gate.density_matrix = True
    initial_rho = random_density_matrix(3)
    final_state = gate(np.copy(initial_rho))

    zero_state = np.array([[1, 0], [0, 0]])
    target_state = np.reshape(initial_rho, 6 * (2,))
    if qubit == 0:
        target_state = np.einsum("aBCabc,Dd->DBCdbc", target_state, zero_state)
    elif qubit == 1:
        target_state = np.einsum("AbCabc,Dd->ADCadc", target_state, zero_state)
    elif qubit == 2:
        target_state = np.einsum("ABcabc,Dd->ABDabd", target_state, zero_state)
    target_state = np.reshape(target_state, (8, 8))
    np.testing.assert_allclose(final_state, target_state)
    qibo.set_backend(original_backend)


def test_partial_trace_traceout_string():
    gate = gates.PartialTrace(0, 2, 3, 4)
    gate.nqubits = 6
    gate.prepare()
    assert gate.traceout_string == "abcdefahcdel->bfhl"
