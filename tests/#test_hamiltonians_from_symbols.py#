"""Test dense matrix of Hamiltonians constructed using symbols."""

import pickle

import numpy as np
import pytest
import sympy

from qibo import hamiltonians, matrices
from qibo.backends import NumpyBackend
from qibo.quantum_info import random_hermitian
from qibo.symbols import I, Symbol, X, Y, Z


@pytest.mark.parametrize("symbol", [I, X, Y, Z])
def test_symbols_pickling(symbol):
    symbol = symbol(int(np.random.randint(4)))
    dumped_symbol = pickle.dumps(symbol)
    new_symbol = pickle.loads(dumped_symbol)
    for attr in ("target_qubit", "name", "_gate"):
        assert getattr(symbol, attr) == getattr(new_symbol, attr)
    np.testing.assert_allclose(symbol.matrix, new_symbol.matrix)


@pytest.mark.parametrize("nqubits", [4, 5])
@pytest.mark.parametrize("hamtype", ["normal", "symbolic"])
@pytest.mark.parametrize("calcterms", [False, True])
def test_tfim_hamiltonian_from_symbols(backend, nqubits, hamtype, calcterms):
    """Check creating TFIM Hamiltonian using sympy."""
    if hamtype == "symbolic":
        h = 0.5
        symham = sum(Z(i, backend=backend) * Z(i + 1, backend=backend) for i in range(nqubits - 1))
        symham += Z(0, backend=backend) * Z(nqubits - 1, backend=backend)
        symham += h * sum(X(i, backend=backend) for i in range(nqubits))
        ham = hamiltonians.SymbolicHamiltonian(-symham, backend=backend)
    else:
        h = 0.5
        z_symbols = sympy.symbols(" ".join(f"Z{i}" for i in range(nqubits)))
        x_symbols = sympy.symbols(" ".join(f"X{i}" for i in range(nqubits)))

        symham = sum(z_symbols[i] * z_symbols[i + 1] for i in range(nqubits - 1))
        symham += z_symbols[0] * z_symbols[-1]
        symham += h * sum(x_symbols)
        symmap = {z: (i, backend.matrices.Z) for i, z in enumerate(z_symbols)}
        symmap.update({x: (i, backend.matrices.X) for i, x in enumerate(x_symbols)})
        ham = hamiltonians.Hamiltonian.from_symbolic(-symham, symmap, backend=backend)

    if calcterms:
        _ = ham.terms
    final_matrix = ham.matrix
    target_matrix = hamiltonians.TFIM(nqubits, h=h, backend=backend).matrix
    backend.assert_allclose(final_matrix, target_matrix)


@pytest.mark.parametrize("hamtype", ["normal", "symbolic"])
@pytest.mark.parametrize("calcterms", [False, True])
def test_from_symbolic_with_power(backend, hamtype, calcterms):
    """Check ``from_symbolic`` when the expression contains powers."""
    npbackend = NumpyBackend()
    if hamtype == "symbolic":
        matrix = random_hermitian(2, backend=npbackend)
        symham = (
            Symbol(0, matrix, backend=backend) ** 2
            - Symbol(1, matrix, backend=backend) ** 2
            + 3 * Symbol(1, matrix, backend=backend)
            - 2 * Symbol(0, matrix, backend=backend) * Symbol(2, matrix, backend=backend)
            + 1
        )
        ham = hamiltonians.SymbolicHamiltonian(symham, backend=backend)
    else:
        z = sympy.symbols(" ".join(f"Z{i}" for i in range(3)))
        symham = z[0] ** 2 - z[1] ** 2 + 3 * z[1] - 2 * z[0] * z[2] + 1
        matrix = random_hermitian(2, backend=npbackend)
        symmap = {x: (i, matrix) for i, x in enumerate(z)}
        ham = hamiltonians.Hamiltonian.from_symbolic(symham, symmap, backend=backend)

    if calcterms:
        _ = ham.terms

    final_matrix = ham.matrix
    matrix2 = matrix.dot(matrix)
    eye = np.eye(2, dtype=matrix.dtype)
    target_matrix = np.kron(np.kron(matrix2, eye), eye)
    target_matrix -= np.kron(np.kron(eye, matrix2), eye)
    target_matrix += 3 * np.kron(np.kron(eye, matrix), eye)
    target_matrix -= 2 * np.kron(np.kron(matrix, eye), matrix)
    target_matrix += np.eye(8, dtype=matrix.dtype)
    backend.assert_allclose(final_matrix, target_matrix)


@pytest.mark.parametrize("hamtype", ["normal", "symbolic"])
@pytest.mark.parametrize("calcterms", [False, True])
def test_from_symbolic_with_complex_numbers(backend, hamtype, calcterms):
    """Check ``from_symbolic`` when the expression contains imaginary unit."""
    if hamtype == "symbolic":
        symham = (
            (1 + 2j) * X(0, backend=backend) * X(1, backend=backend)
            + 2 * Y(0, backend=backend) * Y(1, backend=backend)
            - 3j * X(0, backend=backend) * Y(1, backend=backend)
            + 1j * Y(0, backend=backend) * X(1, backend=backend)
        )
        ham = hamiltonians.SymbolicHamiltonian(symham, backend=backend)
    else:
        x = sympy.symbols(" ".join(f"X{i}" for i in range(2)))
        y = sympy.symbols(" ".join(f"Y{i}" for i in range(2)))
        symham = (
            (1 + 2j) * x[0] * x[1]
            + 2 * y[0] * y[1]
            - 3j * x[0] * y[1]
            + 1j * y[0] * x[1]
        )
        symmap = {s: (i, backend.matrices.X) for i, s in enumerate(x)}
        symmap.update({s: (i, backend.matrices.Y) for i, s in enumerate(y)})
        ham = hamiltonians.Hamiltonian.from_symbolic(symham, symmap, backend=backend)

    if calcterms:
        _ = ham.terms
    final_matrix = ham.matrix
    target_matrix = (1 + 2j) * backend.np.kron(backend.matrices.X, backend.matrices.X)
    target_matrix += 2 * backend.np.kron(backend.matrices.Y, backend.matrices.Y)
    target_matrix -= 3j * backend.np.kron(backend.matrices.X, backend.matrices.Y)
    target_matrix += 1j * backend.np.kron(backend.matrices.Y, backend.matrices.X)
    backend.assert_allclose(final_matrix, target_matrix)


@pytest.mark.parametrize("calcterms", [False, True])
def test_from_symbolic_application_hamiltonian(backend, calcterms):
    """Check ``from_symbolic`` for a specific four-qubit Hamiltonian."""
    z1, z2, z3, z4 = sympy.symbols("z1 z2 z3 z4")
    symmap = {z: (i, matrices.Z) for i, z in enumerate([z1, z2, z3, z4])}
    symham = (
        z1 * z2
        - 0.5 * z1 * z3
        + 2 * z2 * z3
        + 0.35 * z2
        + 0.25 * z3 * z4
        + 0.5 * z3
        + z4
        - z1
    )
    # Check that Trotter dense matrix agrees will full Hamiltonian matrix
    fham = hamiltonians.Hamiltonian.from_symbolic(symham, symmap, backend=backend)
    symham = (
        Z(0, backend=backend) * Z(1, backend=backend)
        - 0.5 * Z(0, backend=backend) * Z(2, backend=backend)
        + 2 * Z(1, backend=backend) * Z(2, backend=backend)
        + 0.35 * Z(1, backend=backend)
        + 0.25 * Z(2, backend=backend) * Z(3, backend=backend)
        + 0.5 * Z(2, backend=backend)
        + Z(3, backend=backend)
        - Z(0, backend=backend)
    )
    sham = hamiltonians.SymbolicHamiltonian(symham, backend=backend)
    if calcterms:
        _ = sham.terms
    backend.assert_allclose(sham.matrix, fham.matrix)


@pytest.mark.parametrize("nqubits", [4, 5])
@pytest.mark.parametrize("hamtype", ["normal", "symbolic"])
@pytest.mark.parametrize("calcterms", [False, True])
def test_x_hamiltonian_from_symbols(backend, nqubits, hamtype, calcterms):
    """Check creating sum(X) Hamiltonian using sympy."""
    if hamtype == "symbolic":
        symham = -sum(X(i, backend=backend) for i in range(nqubits))
        ham = hamiltonians.SymbolicHamiltonian(symham, backend=backend)
    else:
        x_symbols = sympy.symbols(" ".join(f"X{i}" for i in range(nqubits)))
        symham = -sum(x_symbols)
        symmap = {x: (i, backend.
                      matrices.X) for i, x in enumerate(x_symbols)}
        ham = hamiltonians.Hamiltonian.from_symbolic(symham, symmap, backend=backend)
    if calcterms:
        _ = ham.terms
    final_matrix = ham.matrix
    target_matrix = hamiltonians.X(nqubits, backend=backend).matrix
    backend.assert_allclose(final_matrix, target_matrix)


@pytest.mark.parametrize("hamtype", ["normal", "symbolic"])
@pytest.mark.parametrize("calcterms", [False, True])
def test_three_qubit_term_hamiltonian_from_symbols(backend, hamtype, calcterms):
    """Check creating Hamiltonian with three-qubit interaction using sympy."""
    if hamtype == "symbolic":
        symham = X(0, backend=backend) * Y(1, backend=backend) * Z(2, backend=backend) + 0.5 * Y(0, backend=backend) * Z(1, backend=backend) * X(3, backend=backend) + Z(0, backend=backend) * X(2, backend=backend)
        symham += Y(2, backend=backend) + 1.5 * Z(1, backend=backend) - 2 - 3 * X(1, backend=backend) * Y(3, backend=backend)
        ham = hamiltonians.SymbolicHamiltonian(symham, backend=backend)
    else:
        x_symbols = sympy.symbols(" ".join(f"X{i}" for i in range(4)))
        y_symbols = sympy.symbols(" ".join(f"Y{i}" for i in range(4)))
        z_symbols = sympy.symbols(" ".join(f"Z{i}" for i in range(4)))
        symmap = {x: (i, matrices.X) for i, x in enumerate(x_symbols)}
        symmap.update({x: (i, matrices.Y) for i, x in enumerate(y_symbols)})
        symmap.update({x: (i, matrices.Z) for i, x in enumerate(z_symbols)})

        symham = x_symbols[0] * y_symbols[1] * z_symbols[2]
        symham += 0.5 * y_symbols[0] * z_symbols[1] * x_symbols[3]
        symham += z_symbols[0] * x_symbols[2]
        symham += -3 * x_symbols[1] * y_symbols[3]
        symham += y_symbols[2]
        symham += 1.5 * z_symbols[1]
        symham -= 2
        ham = hamiltonians.Hamiltonian.from_symbolic(symham, symmap, backend=backend)

    if calcterms:
        _ = ham.terms
    final_matrix = ham.matrix
    target_matrix = backend.np.kron(
        backend.np.kron(backend.matrices.X, backend.matrices.Y), backend.np.kron(backend.matrices.Z, backend.matrices.I())
    )
    target_matrix += 0.5 * backend.np.kron(
        backend.np.kron(backend.matrices.Y, backend.matrices.Z), backend.np.kron(backend.matrices.I(), backend.matrices.X)
    )
    target_matrix += backend.np.kron(
        backend.np.kron(backend.matrices.Z, backend.matrices.I()), backend.np.kron(backend.matrices.X, backend.matrices.I())
    )
    target_matrix += -3 * backend.np.kron(
        backend.np.kron(backend.matrices.I(), backend.matrices.X), backend.np.kron(backend.matrices.I(), backend.matrices.Y)
    )
    target_matrix += backend.np.kron(
        backend.np.kron(backend.matrices.I(), backend.matrices.I()), backend.np.kron(backend.matrices.Y, backend.matrices.I())
    )
    target_matrix += 1.5 * backend.np.kron(
        backend.np.kron(backend.matrices.I(), backend.matrices.Z), backend.np.kron(backend.matrices.I(), backend.matrices.I())
    )
    target_matrix -= 2 * backend.np.eye(2**4, dtype=target_matrix.dtype)
    backend.assert_allclose(final_matrix, target_matrix)


@pytest.mark.parametrize("calcterms", [False, True])
def test_hamiltonian_with_identity_symbol(backend, calcterms):
    """Check creating Hamiltonian from expression which contains the identity symbol."""
    symham = X(0, backend=backend) * I(1, backend=backend) * Z(2, backend=backend) + 0.5 * Y(0, backend=backend) * Z(1, backend=backend) * I(3, backend=backend) + Z(0, backend=backend) * I(1, backend=backend) * X(2, backend=backend)
    ham = hamiltonians.SymbolicHamiltonian(symham, backend=backend)

    if calcterms:
        _ = ham.terms
    final_matrix = ham.matrix
    target_matrix = backend.np.kron(
        backend.np.kron(backend.matrices.X, backend.matrices.I()), backend.np.kron(backend.matrices.Z, backend.matrices.I())
    )
    target_matrix += 0.5 * np.kron(
        backend.np.kron(backend.matrices.Y, backend.matrices.Z), backend.np.kron(backend.matrices.I(), backend.matrices.I())
    )
    target_matrix += backend.np.kron(
        backend.np.kron(backend.matrices.Z, backend.matrices.I()), backend.np.kron(backend.matrices.X, backend.matrices.I())
    )
    backend.assert_allclose(final_matrix, target_matrix)
